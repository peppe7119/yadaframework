<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.10">
<title>Database Pagination</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<link rel="stylesheet" href="./asciidoctor.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<link rel="stylesheet" type="text/css" href="../../yadadocs.css" />
</head>
<body class="article toc2 toc-left">
<!-- When editing this file, you must copy it in all other folders (without change) -->

<select id="navigator">
	<option>Choose chapter...</option>
	<option data-link="./index.html">Index</option>
	<option data-link="./newEclipseProject.html">Getting started</option>
	<option data-link="./examples/bookstoreTutorial.html">Bookstore tutorial</option>
	<option data-link="./internationalization.html">Internationalization</option>
	<option data-link="./database/pagination.html">Database pagination</option>
	<option data-link="./forms/overview.html">Forms</option>
	<option data-link="./ajax.html">Ajax</option>
	<option data-link="./ajaxModal.html">Ajax Modal</option>
	<option data-link="./datatables.html">DataTables</option>
	<option data-link="./emails.html">Sending Emails</option>
	<option data-link="./notificationModal.html">Notification Modal</option>
	<option data-link="./misc.html">Misc</option>
	<option data-link="./troubleshooting.html">Troubleshooting</option>
	<option data-link="./upgrade.html">Upgrade Yada Framework Version</option>
</select>
<script>
document.querySelector("#navigator").addEventListener("change", function (event) {
	const goup = location.href.lastIndexOf("/") - location.href.lastIndexOf("/en") > 3;
	const link = (goup?"../":"") + this.options[this.selectedIndex].getAttribute("data-link");
	if (link!=null) {
		document.location.href = link;
	}
});
</script>
<div id="header">
<h1>Database Pagination</h1>
<div class="details">
<span id="revnumber">version 0.7.0</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_description">Description</a></li>
<li><a href="#_first_query">First query</a></li>
<li><a href="#_load_more_query">Load More query</a></li>
<li><a href="#_advanced_usage">Advanced Usage</a></li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Fetch big data one piece at a time</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Loading the whole content of a table onto a web page is never a good idea if the row count is high, both
from a performance and usability perspective.
In such case it&#8217;s better to implement database pagination: loading a few rows at a time via ajax when the user wants
to see more.
This section shows how to implement pagination on a web page using a "load more" button, with support
for bookmarking and for the
browser back button: when going back to a web page where more data was loaded, that data is still there.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_first_query">First query</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The "first query" happens when a user loads the web page for the first time, either from normal link navigation
(e.g. a "Show all transactions" link) or by typing a search string into a form and sending it.
The first query will receive any search keywords, will query the database for results, and will return the
results building a page with a "load more" button when there is more data to show.</p>
</div>
<div class="paragraph">
<p>The "first query" is also called when the user later reloads the web page using the browser "refresh" button,
using the browser "back" button or by clicking on a previously saved bookmark.</p>
</div>
<div class="paragraph">
<p>It is therefore important that the method handling the first query receives the information needed to load
as many rows as were loaded by the user using the "load more" button. This information is stored in a <code>YadaPageRequest</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="html" class="language-html hljs">&lt;form th:action="@{/searchBook(sort='title,asc,ignorecase',sort='date,desc')}"&gt; <i class="conum" data-value="1"></i><b>(1)</b>
	&lt;input name="searchString" th:value="${searchString}"&gt;
	&lt;button type="submit"&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The action in this example contains the sort parameters</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Controller
public class BookController {
    final static int PAGE_SIZE =  10;
    @RequestMapping("/searchBook")
    public String searchBook(String searchString, YadaPageRequest yadaPageRequest, Model model) {</code></pre>
</div>
</div>
<div class="paragraph">
<p>When the web page is loaded for the first time, Spring calls the "first query" method and creates an instance of
YadaPageRequest but doesn&#8217;t set any values in it because there are no request parameters to set.
You should check if the yadaPageRequest is valid and set it to a default initial value when it&#8217;s not,
then call the proper DAO to fetch data from the database, that will be stored in a <code>YadaPageRows</code> instance:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">if (!yadaPageRequest.isValid()) {
    yadaPageRequest = new YadaPageRequest(0, PAGE_SIZE);
    yadaPageRequest.addSort("title", false, true);
    yadaPageRequest.addSort("date", true, false);
}
YadaPageRows&lt;Book&gt; result = searchDao.find(searchString, yadaPageRequest);
model.addAttribute("books", result);
return "/searchResult";</code></pre>
</div>
</div>
<div class="paragraph">
<p>The DAO will have to fetch as many rows as needed:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Repository
@Transactional(readOnly = true)
public class SearchDao {
    @PersistenceContext EntityManager em;

    public YadaPageRows&lt;Book&gt; find(String searchString, YadaPageRequest yadaPageRequest) {
        List&lt;Book&gt; found = YadaSql.instance().selectFrom("from Book b")
            .where("b.title LIKE CONCAT('%',:search,'%')")
            .orderBy(yadaPageRequest)
            .setParameter("search", searchString)
            .query(em, Book.class)
            .setFirstResult(yadaPageRequest.getFirstResult())
            .setMaxResults(yadaPageRequest.getMaxResults())
            .getResultList();
        return new YadaPageRows&lt;Book&gt;(found, yadaPageRequest);
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>It is very important to use the <code>setFirstResult</code> and <code>setMaxResults</code> methods as shown above in order to
implement pagination.</p>
</div>
<div class="paragraph">
<p>The result can be shown with the following <code>searchResult.html</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="html" class="language-html hljs">&lt;th:block fragment="bookList" th:unless="${books.empty}"&gt;
	&lt;div th:each="book : ${books}" th:text="${book.title}"&gt;Book title here&lt;/div&gt;

	&lt;div class="jsLoadMoreBooks" th:unless="${books.last}"&gt;
    	&lt;a yada:ajax="@{/searchBookMore(searchString=${searchString},page=${books.nextPage},size=${books.pageSize})}"
        	yada:paginationHistory
            yada:updateOnSuccess="yadaParents:.jsLoadMoreBooks" href=""&gt;Load More
        &lt;/a&gt;
    &lt;/div&gt;
&lt;/th:block&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_load_more_query">Load More query</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The above code prints the found rows, then adds a "Load More" link in case there are more results.
When the user clicks on that link, an ajax call is made to the server in order to fetch the next page:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@RequestMapping("/searchBookMore")
public String searchBookMore(String searchString, YadaPageRequest yadaPageRequest, Model model) {
    YadaPageRows&lt;Book&gt; result = searchDao.find(searchString, yadaPageRequest);
    model.addAttribute("books", result);
    return "/searchResult :: bookList";
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>That&#8217;s all there is to it.</p>
</div>
<div class="paragraph">
<p>The <code>YadaPageRows.isLast()</code> method works automatically with no need for an expensive count query:
the <code>YadaPageRequest</code> will try to fetch one row more than the page size in order to tell
if there are more results to fetch.</p>
</div>
<div class="paragraph">
<p>The <code>yada:paginationHistory</code> attribute, with no value, will add the <code>page</code>, <code>size</code> and <code>loadPrevious</code> request
parameters to the current page URL in the history, so that when using a bookmark, reloading the page or using
the back button those values will be sent to the "first query" method seen at the start, and all
pages up to the current one will be fetched from database and shown. The <code>yada:paginationHistory</code> attribute
must be set on the link or button that loads the next page.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_advanced_usage">Advanced Usage</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This example can be optimized by using a single method both for the first query and for the following ones,
and many paginations can be used on a single web page by keeping distinct <code>yada:paginationHistory</code> parameters,
like <code>yada:paginationHistory="'product.page, product.size, product.loadPrevious'"</code> and <code>yada:paginationHistory="'project.page, project.size, project.loadPrevious'"</code>.</p>
</div>
<div class="paragraph">
<p>To use the same method for the first query and the loadMore ones, just check if the request is ajax
in order to return either the full initial web page or the pagination fragment:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public String searchBook(String searchString, YadaPageRequest yadaPageRequest, Model model) {
	...
	return yadaWebUtil.isAjaxRequest() ? "/searchResult :: bookList" : "/searchResult";</code></pre>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Version 0.7.0<br>
Last updated 2021-11-26 19:35:05 +0100
</div>
</div>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/styles/github.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/highlight.min.js"></script>
<script>hljs.initHighlighting()</script>
</body>
</html>